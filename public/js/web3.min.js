export default{instance:null,events:{},init:async function(){return this.instance=new Web3(window.ethereum),window.ethereum?(this.injected=!0,window.ethereum.on("accountsChanged",()=>{console.log("Account changed"),this.changeAccount()}),window.ethereum.on("networkChanged",()=>{console.log("Network changed"),this.changeNetwork()}),this.contract.instance=this.instance,await this.connect()&&(this.changeNetwork(),this.changeAccount()),!0):(this.providerAvailable=!1,console.log("No web3 provider detected"),!1)},connect:async function(){if(this.injected)try{return await ethereum.enable(),this.connected=!0,this.events.connect&&this.events.connect(),!0}catch(error){return console.log("user rejected permission"),!1}return!1},getAccount:async function(){return(await this.instance.eth.getAccounts())[0]},getNetworkId:async function(){return await this.instance.eth.net.getId()},getBalance:async function(){let balance=await this.instance.eth.getBalance(await this.getAccount());return balance=this.instance.utils.fromWei(balance),balance},changeAccount:async function(){this.instance.eth.getAccounts((err,accounts)=>{null==err?0!=accounts.length?(this.account=accounts[0],console.log("Account: "+this.account),this.instance.eth.defaultAccount=this.account,this.events.accountChange&&this.events.accountChange(this.account)):alert("No account found! Make sure the Ethereum client is configured properly."):alert("Error retrieving accounts.")})},changeNetwork:async function(){this.networkId=await this.instance.eth.net.getId(),console.log(`Network: ${this.networkId}`),this.events.networkChange&&this.events.networkChange(this.networkId)},switchNetwork:async function(network){try{await ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:this.instance.utils.toHex(network.id)}]}),this.changeNetwork()}catch(err){if(4902===err.code)return console.log("Network not added"),await this.addNetwork(network),void await this.switchNetwork(network);console.log(err)}},addNetwork:async function(network){await ethereum.request({method:"wallet_addEthereumChain",params:[{chainName:network.longName||network.name,chainId:this.instance.utils.toHex(network.id),nativeCurrency:{name:network.token,decimals:18,symbol:network.token},rpcUrls:[network.rpc]}]})},on:async function(event,callback){this.events[event]=callback},contract:{list:{},add:function(addr,abi,name){return"string"==typeof abi&&(abi=JSON.parse(abi)),name||(name=addr),this.list[name]=new this.instance.eth.Contract(abi,addr),this.list[name]},get:function(id){return this.list[id]}},send:function({from:from,to:to,value:value,gasPrice:gasPrice}){const message="Waiting for tx...";console.log(message),this.events.status&&this.events.status(message);const args={to:to,from:from,value:this.instance.utils.toWei(Number(value).toString(),"ether")};return gasPrice&&(args.gasPrice=gasPrice),this.instance.eth.sendTransaction(args)},waitConfirmation:async function(hash,{interval:interval=1e3,verbose:verbose=!1}={}){verbose&&console.log(`Checking tx ${hash}...`);const tx={};tx.hash=hash,tx.startBlock=await this.instance.eth.getBlockNumber();const getTx=async()=>{try{const confirm=await this.instance.eth.getTransaction(hash);if(!confirm){verbose&&console.log("Tx expired. Searching for replacement tx...");const newTx=await this.findReplacementTx(tx);return"success"==newTx.status?(verbose&&console.log("Found replacemente tx"),{status:newTx.cancel?"cancelled":"replaced",tx:newTx.tx}):{error:!0,status:"fail",response:"Could not find Tx"}}return confirm.blockNumber?(verbose&&(console.log("Tx confirmed:"),console.log(confirm)),{status:"confirmed",tx:confirm}):(tx.nonce||(tx.nonce=confirm.nonce,tx.from=confirm.from.toLowerCase()),await new Promise(resolve=>setTimeout(async()=>{const wait=await getTx();resolve(wait)},interval)))}catch(error){return verbose&&(console.log("Tx error:"),console.log(error)),{error:!0,status:"error",response:error}}};return await getTx()},findReplacementTx:async function(tx){const thisBlock=await this.instance.eth.getBlockNumber();let n=tx.startBlock;const maxScanLength=20;for(;n-thisBlock<20;){const block=await this.instance.eth.getBlock(n,!0);if(block){if(block.transactions){const match=block.transactions.filter(t=>t.from.toLowerCase()==tx.from&&t.nonce==tx.nonce);if(match.length){const res={status:"success",tx:match[0]};return match[0].from==match[0].to&&(res.cancel=!0),res}}n++}}return{status:"fail",message:"Could not find the replacement tx"}}};
//# sourceMappingURL=web3.min.js.map